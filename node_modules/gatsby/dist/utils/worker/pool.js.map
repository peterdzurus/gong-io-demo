{"version":3,"sources":["../../../src/utils/worker/pool.ts"],"names":["create","numWorkers","Math","max","reporter","verbose","worker","WorkerPool","require","resolve","env","GATSBY_NODE_GLOBALS","JSON","stringify","global","__GATSBY","GATSBY_WORKER_POOL_WORKER","GATSBY_SKIP_WRITING_SCHEMA_TO_FILE","queriesChunkSize","Number","process","GATSBY_PARALLEL_QUERY_CHUNK_SIZE","handleRunQueriesInWorkersQueueError","e","panic","id","context","error","runQueriesInWorkersQueue","pool","queryIds","chunkSize","activity","createProgress","staticQueryIds","length","pageQueryIds","start","staticQuerySegments","pageQuerySegments","all","setComponents","segment","single","runQueries","then","replayWorkerActions","tick","catch","Promise","saveQueriesDependencies","end","mergeWorkerState","activityTimer","workerId","getWorkerInfo","state","String","queryStateChunk","queries","store","dispatch","type","payload","nextTick","actions","i","action"],"mappings":"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","sourcesContent":["import { WorkerPool } from \"gatsby-worker\"\nimport { chunk } from \"lodash\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { cpuCoreCount } from \"gatsby-core-utils\"\n\nimport { IGroupedQueryIds } from \"../../services\"\nimport { initJobsMessagingInMainProcess } from \"../jobs/worker-messaging\"\nimport { initReporterMessagingInMainProcess } from \"./reporter\"\n\nimport { GatsbyWorkerPool } from \"./types\"\nimport { loadPartialStateFromDisk, store } from \"../../redux\"\nimport { ActionsUnion, IGatsbyState } from \"../../redux/types\"\n\nexport type { GatsbyWorkerPool }\n\nexport const create = (): GatsbyWorkerPool => {\n  const numWorkers = Math.max(1, cpuCoreCount() - 1)\n  reporter.verbose(`Creating ${numWorkers} worker`)\n\n  const worker: GatsbyWorkerPool = new WorkerPool(require.resolve(`./child`), {\n    numWorkers,\n    env: {\n      GATSBY_NODE_GLOBALS: JSON.stringify(global.__GATSBY ?? {}),\n      GATSBY_WORKER_POOL_WORKER: `true`,\n      GATSBY_SKIP_WRITING_SCHEMA_TO_FILE: `true`,\n    },\n  })\n\n  initJobsMessagingInMainProcess(worker)\n  initReporterMessagingInMainProcess(worker)\n\n  return worker\n}\n\nconst queriesChunkSize =\n  Number(process.env.GATSBY_PARALLEL_QUERY_CHUNK_SIZE) || 50\n\nfunction handleRunQueriesInWorkersQueueError(e: Error): never {\n  reporter.panic({\n    id: `85928`,\n    context: {},\n    error: e,\n  })\n}\n\nexport async function runQueriesInWorkersQueue(\n  pool: GatsbyWorkerPool,\n  queryIds: IGroupedQueryIds,\n  chunkSize = queriesChunkSize\n): Promise<void> {\n  const activity = reporter.createProgress(\n    `run queries in workers`,\n    queryIds.staticQueryIds.length + queryIds.pageQueryIds.length\n  )\n  activity.start()\n  try {\n    const staticQuerySegments = chunk(queryIds.staticQueryIds, chunkSize)\n    const pageQuerySegments = chunk(queryIds.pageQueryIds, chunkSize)\n\n    pool.all.setComponents()\n\n    for (const segment of staticQuerySegments) {\n      pool.single\n        .runQueries({ pageQueryIds: [], staticQueryIds: segment })\n        .then(replayWorkerActions)\n        .then(() => {\n          activity.tick(segment.length)\n        })\n        .catch(handleRunQueriesInWorkersQueueError)\n    }\n\n    for (const segment of pageQuerySegments) {\n      pool.single\n        .runQueries({ pageQueryIds: segment, staticQueryIds: [] })\n        .then(replayWorkerActions)\n        .then(() => {\n          activity.tick(segment.length)\n        })\n        .catch(handleRunQueriesInWorkersQueueError)\n    }\n\n    // note that we only await on this and not on anything before (`.setComponents()` or `.runQueries()`)\n    // because gatsby-worker will queue tasks internally and worker will never execute multiple tasks at the same time\n    // so awaiting `.saveQueriesDependencies()` is enough to make sure `.setComponents()` and `.runQueries()` finished\n    await Promise.all(pool.all.saveQueriesDependencies())\n  } catch (e) {\n    handleRunQueriesInWorkersQueueError(e)\n  } finally {\n    activity.end()\n  }\n}\n\nexport async function mergeWorkerState(pool: GatsbyWorkerPool): Promise<void> {\n  const activity = reporter.activityTimer(`Merge worker state`)\n  activity.start()\n\n  for (const { workerId } of pool.getWorkerInfo()) {\n    const state = loadPartialStateFromDisk([`queries`], String(workerId))\n    const queryStateChunk = state.queries as IGatsbyState[\"queries\"]\n    if (queryStateChunk) {\n      // When there are too little queries, some worker can be inactive and its state is empty\n      store.dispatch({\n        type: `MERGE_WORKER_QUERY_STATE`,\n        payload: {\n          workerId,\n          queryStateChunk,\n        },\n      })\n      await new Promise(resolve => process.nextTick(resolve))\n    }\n  }\n  activity.end()\n}\n\nasync function replayWorkerActions(\n  actions: Array<ActionsUnion>\n): Promise<void> {\n  let i = 1\n  for (const action of actions) {\n    store.dispatch(action)\n\n    // Give event loop some breath\n    if (i++ % 100 === 0) {\n      await new Promise(resolve => process.nextTick(resolve))\n    }\n  }\n}\n"],"file":"pool.js"}